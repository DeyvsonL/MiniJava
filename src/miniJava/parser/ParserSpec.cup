package miniJava.parser;

import java_cup.runtime.*;

// Imports adicionados
import java.io.IOException;
import java.nio.file.Path;
import miniJava.astree.*;
import miniJava.astree.dataType.*;
import miniJava.astree.expression.*;
import miniJava.astree.expression.booleanExpr.*;
import miniJava.astree.expression.integerExpr.*;
import miniJava.astree.statement.*;
import miniJava.lexer.Lexer;

parser code {:

    // Salvando lexer e o arquivo como objetos da classe
    private Lexer lexer;

    // Salvando arquivo, talvez para algum futuro uso
    private Path file;

    // Criando novo construtor onde é possivel setar um arquivo para ser analizado
    public Parser(Path file) throws IOException {

        // Salvando refrencia do arquivo
        this.file = file;

        // Criando um gerador de simbolos que sera salva na superclasse do lexer e no parser
        // (não sei o porque de salvar no lexer)
        ComplexSymbolFactory symbolFactory = new ComplexSymbolFactory();

        // Superclasse lr_parser contem este atributo
        super.symbolFactory = symbolFactory;

        // Inicializando o lexer com o arquivo recebido e o gerador de simbolos
        // Construtor abaixo descrito na especificação do lexer
        // Tambem pode lançar execessão, que deve ser capturada ou lançar novamente por esse construtor
        this.lexer = new Lexer(file, symbolFactory);
    }
:}

init with {:
:};

scan with {:
    // Função de scanner que é criada automaticamente pela integração do jflex com o cup na especificação do lexer
    return lexer.next_token();
:};


// Definição de terminais
terminal CLASS, PUBLIC, EXTENDS, STATIC, VOID, INT, BOOLEAN, WHILE, IF, ELSE, RETURN, THIS, NEW,
         SEMICOLON, DOT, COMMA, ASSIGN, O_PAR, C_PAR, O_BRAC, C_BRAC, O_BRACK, C_BRACK,
         OR, AND, EQUALS, DIFF, LESS, LESS_EQ, GREATER, GREATER_EQ, PLUS, MINUS, TIMES, SLASH, PERCENT, OPP;
terminal Boolean FALSE, TRUE;
terminal Integer INTEGER;
terminal Double FLOAT;
terminal String ID;

// Terminais do main, println e length
terminal MAIN, PRINTLN, LENGTH;

// Definição dos não terminais (deve haver uma classe da arvore sintática abstrata para cada não terminal)
non terminal Program prog;
non terminal MainClassDecl mClass;
non terminal ClassDeclList classList;
non terminal ClassDecl clas;
non terminal Extends ext;
non terminal VariableDeclList varList;
non terminal VariableDecl var;
non terminal MethodDeclList methodList;
non terminal MethodDecl method;
non terminal ParameterList paramList;
non terminal Parameters params;
non terminal Parameter param;
non terminal DataType type;
non terminal StatementList stmtList;
non terminal Statement stmt;
non terminal Expression expr;
non terminal ArgumentList argList;
non terminal Arguments args;

// Regras de precedencia

// Atribuição associa a direita
precedence right ASSIGN;

// And e or associam a esquerda sempre, como operações quaisquer
precedence left AND, OR;

// Já o operador de negação associa a direita
precedence right OPP;

// Operações de comparação associam a esquerda
precedence left EQUALS, DIFF, LESS, LESS_EQ, GREATER, GREATER_EQ;

// Associa acima e a esquerda operações de soma e subtração
precedence left PLUS, MINUS;
// Associa a esquerda apos operações de soma e subtração, pus mod no mesmo nivel de divisão
precedence left TIMES, SLASH, PERCENT;

// New associa com o tipo a sua direita
precedence right NEW;

// IDs não associam
precedence nonassoc ID;

// Ponto é referencia, então associa a esquerda sempre
precedence left DOT;

// Gramática

prog        ::= mClass:m classList:cl                                   {:RESULT = new Program(m, cl);:}
            ;

mClass      ::= CLASS ID:n O_BRAC PUBLIC STATIC VOID MAIN O_PAR ID O_BRACK C_BRACK ID C_PAR O_BRAC stmtList:b C_BRAC C_BRAC
                                                                        {:RESULT = new MainClassDecl(n, b);:}
            ;

classList   ::= clas:c classList:cl                                     {:RESULT = new ClassDeclList(c, cl);:}
                |                                                       {:RESULT = null;:}
            ;

clas        ::= CLASS ID:n ext:e O_BRAC varList:v methodList:m C_BRAC
                                                                        {:RESULT = new ClassDecl(n, e, v, m);:}
            ;

ext         ::= EXTENDS ID:n                                            {:RESULT = new Extends(n);:}
                |                                                       {:RESULT = null;:}
            ;

varList     ::= var:v varList:vl                                        {:RESULT = new VariableDeclList(v, vl);:}
                |                                                       {:RESULT = null;:}
            ;

var         ::= type:t ID:n SEMICOLON                                   {:RESULT = new VariableDecl(t, n);:}
            ;

methodList  ::= method:m methodList:ml                                  {:RESULT = new MethodDeclList(m, ml);:}
                |                                                       {:RESULT = null;:}
            ;

method      ::= PUBLIC type:t ID:n O_PAR paramList:p C_PAR O_BRAC varList:v stmtList:s RETURN expr:r SEMICOLON C_BRAC
                                                                        {:RESULT = new MethodDecl(t, n, p, v, s, r);:}
            ;

paramList   ::= params:ps                                               {:RESULT = new ParameterList(ps);:}
                |                                                       {:RESULT = null;:}
            ;

params      ::= param:p COMMA params:ps                                 {:RESULT = new Parameters(p, ps);:}
                | param:p                                               {:RESULT = new Parameters(p, null);:}
            ;

param       ::= type:t ID:n                                             {:RESULT = new Parameter(t, n);:}
            ;

type        ::= INT                                                     {:RESULT = new IntegerType();:}
                | INT O_BRACK C_BRACK                                   {:RESULT = new IntegerArrayType();:}
                | BOOLEAN                                               {:RESULT = new BooleanType();:}
                | ID                                                    {:RESULT = new IdentifierType();:}
            ;

stmtList    ::= stmt:s stmtList:sl                                    {:RESULT = new StatementList(s, sl);:}
                |                                                       {:RESULT = null;:}
            ;
stmt        ::= O_BRAC stmtList:s C_BRAC                                {:RESULT = new BraceStatement(s);:}
                | IF O_PAR expr:c C_PAR stmtList:i ELSE stmtList:e      {:RESULT = new IfElseStatement(c, i, e);:}
                | WHILE O_PAR expr:e C_PAR stmtList:s                   {:RESULT = new WhileStatement(e, s);:}
                | PRINTLN O_PAR expr:e C_PAR SEMICOLON                  {:RESULT = new PrintStatement(e);:}
                | ID:v ASSIGN expr:e SEMICOLON                          {:RESULT = new AssignStatement(v, e);:}
                | ID:v O_BRACK expr:i C_BRACK ASSIGN expr:e SEMICOLON   {:RESULT = new AssignArrayStatement(v, i, e);:}
            ;

expr        ::= expr:l OR expr:r                                        {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.OR, r);:}
                | expr:l AND expr:r                                     {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.AND, r);:}
                | expr:l EQUALS expr:r                                  {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.EQUALS, r);:}
                | expr:l DIFF expr:r                                    {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.DIFF, r);:}
                | expr:l LESS expr:r                                    {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.LESS, r);:}
                | expr:l LESS_EQ expr:r                                 {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.LESS_THAN, r);:}
                | expr:l GREATER expr:r                                 {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.GREATER, r);:}
                | expr:l GREATER_EQ expr:r                              {:RESULT = new BinaryBooleanExpression(l, BinaryBooleanExpression.Operator.GREATER_THAN, r);:}
                | expr:l PLUS expr:r                                    {:RESULT = new BinaryIntegerExpression(l, BinaryIntegerExpression.Operator.PLUS, r);:}
                | expr:l MINUS expr:r                                   {:RESULT = new BinaryIntegerExpression(l, BinaryIntegerExpression.Operator.MINUS, r);:}
                | expr:l TIMES expr:r                                   {:RESULT = new BinaryIntegerExpression(l, BinaryIntegerExpression.Operator.TIMES, r);:}
                | expr:l SLASH expr:r                                   {:RESULT = new BinaryIntegerExpression(l, BinaryIntegerExpression.Operator.DIV, r);:}
                | expr:l PERCENT expr:r                                 {:RESULT = new BinaryIntegerExpression(l, BinaryIntegerExpression.Operator.MOD, r);:}
                | OPP expr:e                                            {:RESULT = new UnaryBooleanExpression(UnaryBooleanExpression.Operator.OPPOSITE, e);:}
                | expr:a O_BRACK expr:i C_BRACK                         {:RESULT = new ArrayAccessExpression(a, i);:}
                | expr:a DOT LENGTH                                     {:RESULT = new LengthExpression(a);:}
                | expr:o DOT ID:m O_PAR argList:al C_PAR                {:RESULT = new FunctionExpression(o, m, al);:}
                | INTEGER:v                                             {:RESULT = new LiteralIntegerExpression(v);:}
                | FALSE:v                                               {:RESULT = new LiteralBooleanExpression(v);:}
                | TRUE:v                                                {:RESULT = new LiteralBooleanExpression(v);:}
                | ID:v                                                  {:RESULT = new IdentifierExpression(v);:}
                | THIS                                                  {:RESULT = new ThisExpression();:}
                | NEW INT O_BRACK expr:s C_BRACK                        {:RESULT = new IntegerArrayCreationExpression(s);:}
                | NEW ID:n O_PAR C_PAR                                  {:RESULT = new ObjectCreationExpression(n);:}
                | O_PAR expr:e C_PAR                                    {:RESULT = new AssocExpression(e);:}
            ;

argList     ::= args:a                                                  {:RESULT = new ArgumentList(a);:}
                |                                                       {:RESULT = new ArgumentList(null);:}
            ;

args        ::= expr:a COMMA args:as                                    {:RESULT = new Arguments(a, as);:}
                | expr:a                                                {:RESULT = new Arguments(a, null);:}
            ;